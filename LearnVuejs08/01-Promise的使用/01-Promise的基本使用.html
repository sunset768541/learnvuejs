<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // setTimeout(() => {
    //     console.log('hello world');
    // }, 1000)
    //resolve reject本身就是函数

    //这种写法产生了回调地狱
    // new Promise((resolve, reject) => {
    //     setTimeout(() => {//耗时函数1s
    //         console.log('hello world');
    //         console.log('hello world');
    //         console.log('hello world');
    //         console.log('hello world');
    //         console.log('hello world');
    //         console.log('hello world');
    //         setTimeout(() => {
    //             console.log('hello vuejs');
    //             console.log('hello vuejs');
    //             console.log('hello vuejs');
    //             console.log('hello vuejs');
    //             console.log('hello vuejs');
    //             setTimeout(() => {
    //                 console.log('hello python');
    //                 console.log('hello python');
    //                 console.log('hello python');
    //                 console.log('hello python');
    //                 console.log('hello python');
    //                 console.log('hello python');
    //             }, 1000)
    //         }, 1000)
    //     }, 1000)
    // })
    //
    // //
    //
    // new Promise((resolve, reject) => {
    //     setTimeout(() => {
    //         //第一次网络请求代码
    //         resolve()
    //     }, 1000)
    // }).then(() => {
    //     //第一次网络请求处理代码
    //     console.log('hello world');
    //     console.log('hello world');
    //     console.log('hello world');
    //     console.log('hello world');
    //     console.log('hello world');
    //     console.log('hello world');
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             //第二次网络请求代码
    //             resolve()
    //         }, 1000)
    //     })
    // }).then(() => {
    //         //第二次网络请求处理代码
    //         console.log('hello vuejs');
    //         console.log('hello vuejs');
    //         console.log('hello vuejs');
    //         console.log('hello vuejs');
    //         console.log('hello vuejs');
    //         return new Promise((resolve, reject) => {
    //             setTimeout(() => {
    //                 //第三次网络请求代码
    //                 resolve()
    //             }, 1000)
    //         })
    //     }
    // ).then(() => {
    //     //第三次网络请求处理代码
    //     console.log('hello python');
    //     console.log('hello python');
    //     console.log('hello python');
    //     console.log('hello python');
    //     console.log('hello python');
    //     console.log('hello python');
    // })


    //什么情况下用到Promise ?一般情况下有异步操作时，使用Promise对异步操作进行封装
    //执行我们传入的回调函数时，会传入2个参数，resolve和reject又是函数
    new Promise((resolve, reject) => {
        setTimeout(() => {
            //Promise不希望我们在这里直接处理data
            resolve('hello ')
            //失败的时候调用reject
        }, 1000)
    }).then((data) => {
        //在这里处理data
        console.log(data);
        console.log(data);
        console.log(data);
        console.log(data);
        console.log(data);
        console.log(data);
    }).catch((err) => {
        //处理reject
        console.log(err);
    })
</script>
</body>
</html>